import "./chunk-FJLWZCXQ.js";

// ../../node_modules/@web3-onboard/walletconnect/dist/index.js
var isHexString = (value) => {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  return true;
};
function walletConnect(options) {
  const { bridge = "https://bridge.walletconnect.org", qrcodeModalOptions, connectFirstChainId } = options || {};
  return () => {
    return {
      label: "WalletConnect",
      getIcon: async () => (await import("./icon-GREGKH4U.js")).default,
      getInterface: async ({ chains, EventEmitter }) => {
        const { StaticJsonRpcProvider } = await import("./lib-222VM4XC.js");
        const { ProviderRpcError, ProviderRpcErrorCode } = await import("./dist-467KSXWL.js");
        const { default: WalletConnect } = await import("./esm-NFZNKK7Q.js");
        let QRCodeModal = await import("./cjs-VYZIVCTC.js");
        QRCodeModal = QRCodeModal.default || QRCodeModal;
        const { Subject, fromEvent } = await import("./esm5-6PLGKDX3.js");
        const { takeUntil, take } = await import("./operators-L6I6KJGH.js");
        const connector = new WalletConnect({
          bridge
        });
        const emitter = new EventEmitter();
        class EthProvider {
          constructor({ connector: connector2, chains: chains2 }) {
            this.emit = emitter.emit.bind(emitter);
            this.on = emitter.on.bind(emitter);
            this.removeListener = emitter.removeListener.bind(emitter);
            this.connector = connector2;
            this.chains = chains2;
            this.disconnected$ = new Subject();
            this.providers = {};
            fromEvent(this.connector, "session_update", (error, payload) => {
              if (error) {
                throw error;
              }
              return payload;
            }).pipe(takeUntil(this.disconnected$)).subscribe({
              next: ({ params }) => {
                const [{ accounts, chainId }] = params;
                this.emit("accountsChanged", accounts);
                const hexChainId = isHexString(chainId) ? chainId : `0x${chainId.toString(16)}`;
                this.emit("chainChanged", hexChainId);
              },
              error: console.warn
            });
            fromEvent(this.connector, "disconnect", (error, payload) => {
              if (error) {
                throw error;
              }
              return payload;
            }).pipe(takeUntil(this.disconnected$)).subscribe({
              next: () => {
                this.emit("accountsChanged", []);
                this.disconnected$.next(true);
                typeof localStorage !== "undefined" && localStorage.removeItem("walletconnect");
              },
              error: console.warn
            });
            this.disconnect = () => this.connector.killSession();
            this.request = async ({ method, params }) => {
              if (method === "eth_chainId") {
                return isHexString(this.connector.chainId) ? this.connector.chainId : `0x${this.connector.chainId.toString(16)}`;
              }
              if (method === "eth_requestAccounts") {
                return new Promise((resolve, reject) => {
                  if (!this.connector.connected) {
                    this.connector.createSession(connectFirstChainId ? { chainId: parseInt(chains2[0].id, 16) } : void 0).then(() => {
                      QRCodeModal.open(this.connector.uri, () => reject(new ProviderRpcError({
                        code: 4001,
                        message: "User rejected the request."
                      })), qrcodeModalOptions);
                    });
                  } else {
                    const { accounts, chainId: chainId2 } = this.connector.session;
                    const hexChainId = isHexString(chainId2) ? chainId2 : `0x${chainId2.toString(16)}`;
                    this.emit("chainChanged", hexChainId);
                    return resolve(accounts);
                  }
                  fromEvent(this.connector, "connect", (error, payload) => {
                    if (error) {
                      throw error;
                    }
                    return payload;
                  }).pipe(take(1)).subscribe({
                    next: ({ params: params2 }) => {
                      const [{ accounts, chainId: chainId2 }] = params2;
                      this.emit("accountsChanged", accounts);
                      const hexChainId = isHexString(chainId2) ? chainId2 : `0x${chainId2.toString(16)}`;
                      this.emit("chainChanged", hexChainId);
                      QRCodeModal.close();
                      resolve(accounts);
                    },
                    error: reject
                  });
                });
              }
              if (method === "eth_selectAccounts") {
                throw new ProviderRpcError({
                  code: ProviderRpcErrorCode.UNSUPPORTED_METHOD,
                  message: `The Provider does not support the requested method: ${method}`
                });
              }
              if (method == "wallet_switchEthereumChain") {
                if (!params) {
                  throw new ProviderRpcError({
                    code: ProviderRpcErrorCode.INVALID_PARAMS,
                    message: `The Provider requires a chainId to be passed in as an argument`
                  });
                }
                const chainIdObj = params[0];
                if (!chainIdObj.hasOwnProperty("chainId") || typeof chainIdObj["chainId"] === "undefined") {
                  throw new ProviderRpcError({
                    code: ProviderRpcErrorCode.INVALID_PARAMS,
                    message: `The Provider requires a chainId to be passed in as an argument`
                  });
                }
                return this.connector.sendCustomRequest({
                  method: "wallet_switchEthereumChain",
                  params: [
                    {
                      chainId: chainIdObj.chainId
                    }
                  ]
                });
              }
              if (method === "eth_sendTransaction") {
                return this.connector.sendTransaction(params[0]);
              }
              if (method === "eth_signTransaction") {
                return this.connector.signTransaction(params[0]);
              }
              if (method === "personal_sign") {
                return this.connector.signPersonalMessage(params);
              }
              if (method === "eth_sign") {
                return this.connector.signMessage(params);
              }
              if (method.includes("eth_signTypedData")) {
                return this.connector.signTypedData(params);
              }
              if (method === "eth_accounts") {
                return this.connector.sendCustomRequest({
                  id: 1337,
                  jsonrpc: "2.0",
                  method,
                  params
                });
              }
              const chainId = await this.request({ method: "eth_chainId" });
              if (!this.providers[chainId]) {
                const currentChain = chains2.find(({ id }) => id === chainId);
                if (!currentChain) {
                  throw new ProviderRpcError({
                    code: ProviderRpcErrorCode.CHAIN_NOT_ADDED,
                    message: `The Provider does not have a rpcUrl to make a request for the requested method: ${method}`
                  });
                }
                this.providers[chainId] = new StaticJsonRpcProvider(currentChain.rpcUrl);
              }
              return this.providers[chainId].send(
                method,
                params
              );
            };
          }
        }
        return {
          provider: new EthProvider({ chains, connector })
        };
      }
    };
  };
}
var dist_default = walletConnect;
export {
  dist_default as default
};
//# sourceMappingURL=@web3-onboard_walletconnect.js.map
